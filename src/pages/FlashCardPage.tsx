import React, { useState, useEffect } from 'react';
import { useParams, Link } from 'react-router-dom';
import { fetchArticleContent } from '../services/api';
import { generateFlashcards } from '../utils/flashcardUtils';
import FlashcardCreator from '../components/FlashcardCreator';
import FlashcardReview from '../components/FlashcardReview';
import FullTextModal from '../components/FullTextModal';
const FlashcardsPage = () => {
    console.log("FlashcardsPage loaded");
console.log("generateFlashcards function imported:", typeof generateFlashcards);
  const { title } = useParams();
  const [modalOpen, setModalOpen] = useState(false);
const [modalContent, setModalContent] = useState({ title: '', content: '' });
  const [article, setArticle] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [autoGeneratedCards, setAutoGeneratedCards] = useState([]);
  const [userCards, setUserCards] = useState([]);
  const [activeTab, setActiveTab] = useState('generate'); // 'generate', 'review', 'custom'
  const [reviewSettings, setReviewSettings] = useState({
    cardTypes: ['qa', 'cloze', 'mcq'],
    difficulty: 'medium',
    deckSize: 10
  });
  const [reviewInProgress, setReviewInProgress] = useState(false);
  const [reviewDeck, setReviewDeck] = useState([]);
  const [selectedSection, setSelectedSection] = useState('all');
  const [sections, setSections] = useState([]);

  // Load article content and user's saved cards
  useEffect(() => {
    const fetchArticleData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        // Fetch article content
        const articleData = await fetchArticleContent(title);
        setArticle(articleData);
        
        // Extract sections
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = articleData.text;
        const headings = Array.from(tempDiv.querySelectorAll('h2, h3'));
        const extractedSections = headings.map(heading => ({
          id: heading.id || heading.textContent.toLowerCase().replace(/\s+/g, '-'),
          title: heading.textContent,
          level: heading.tagName === 'H2' ? 2 : 3
        }));
        
        // Add 'All' option
        setSections([
          { id: 'all', title: 'All Sections', level: 1 },
          ...extractedSections
        ]);
        
        // Load user's saved cards for this article
        const savedCards = await loadUserCards(title);
        setUserCards(savedCards);
        
      } catch (err) {
        setError(err.message || 'Failed to fetch article');
        console.error('Error loading flashcards data:', err);
      } finally {
        setLoading(false);
      }
    };

    if (title) {
      fetchArticleData();
    }
  }, [title]);

  // Load user-saved flashcards
  const loadUserCards = async (articleTitle) => {
    try {
      // In a real app, this would call an API endpoint
      // For this demo, we'll use localStorage
      const key = `wiki-flashcards-${articleTitle}`;
      const storedCards = localStorage.getItem(key);
      
      if (storedCards) {
        return JSON.parse(storedCards);
      }
      
      return [];
    } catch (error) {
      console.error('Error loading user cards:', error);
      return [];
    }
  };

  // Save user flashcards
  const saveUserCards = async (cards) => {
    try {
      // In a real app, this would call an API endpoint
      // For this demo, we'll use localStorage
      const key = `wiki-flashcards-${title}`;
      localStorage.setItem(key, JSON.stringify(cards));
      return true;
    } catch (error) {
      console.error('Error saving user cards:', error);
      return false;
    }
  };

  // Generate flashcards for the selected section
// In FlashcardsPage.jsx, check and fix the handleGenerateFlashcards function
function generateBasicFlashcards(content, difficulty = 'medium') {
    console.log("Running flashcard generator on content length:", content.length);
    
    // Create a parser for the content
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    
    // Get paragraphs and headings
    const paragraphs = Array.from(tempDiv.querySelectorAll('p'));
    const headings = Array.from(tempDiv.querySelectorAll('h2, h3, h4'));
    
    console.log("Found paragraphs:", paragraphs.length);
    console.log("Found headings:", headings.length);
    
    // Initialize cards array
    const cards = [];
    
    // Only proceed if we have some content to work with
    if (paragraphs.length === 0 && headings.length === 0) {
      console.warn("No paragraphs or headings found in the content");
      // Create at least one card even if no structure is found
      cards.push({
        id: `qa-${Date.now()}-default`,
        type: 'qa',
        front: "What information can you find in this section?",
        back: "This section contains information about the topic.",
        fullText: {
          front: "What information can you find in this section?",
          back: "This section contains information about the topic."
        }
      });
      return cards;
    }
    
    // Create Q&A cards from paragraphs
    paragraphs.forEach((paragraph, index) => {
      const text = paragraph.textContent.trim();
      if (text.length > 40) {
        // Create a question based on the paragraph context
        let question;
        
        // If we have a nearby heading, use it for context
        const nearestHeading = headings.find(h => h.compareDocumentPosition(paragraph) & Node.DOCUMENT_POSITION_PRECEDING);
        
        if (nearestHeading) {
          question = `What does the article say about ${nearestHeading.textContent.trim()}?`;
        } else {
          // Generic questions if no heading is found
          const genericQuestions = [
            "What information is provided in this section?",
            "What key facts are mentioned in this paragraph?",
            "What important details are described here?",
            "What main points are covered in this text?"
          ];
          question = genericQuestions[index % genericQuestions.length];
        }
        
        // Store both the truncated text for card display and full text for modal
        const truncatedText = text.length > 150 ? text.substring(0, 150) + "..." : text;
        
        cards.push({
          id: `qa-${Date.now()}-${index}`,
          type: 'qa',
          front: question,
          back: truncatedText, // Truncated for card display
          fullText: {
            front: question,
            back: text // Full text for modal
          }
        });
      }
    });
    
    // Create cloze deletion cards
    paragraphs.forEach((paragraph, index) => {
      // Only use a subset of paragraphs for variety
      if (index % 3 !== 0) return;
      
      const text = paragraph.textContent.trim();
      if (text.length < 50) return;
      
      // Find important terms to create cloze deletions
      const words = text.split(/\s+/);
      
      // Look for proper nouns, longer words, or words with capital letters
      const candidateWords = words.filter(word => 
        (word.length > 6 && /^[A-Z]/.test(word)) || // Capitalized long word
        word.length > 8 || // Very long word
        /^[A-Z][a-z]+$/.test(word) // Proper noun
      );
      
      if (candidateWords.length > 0) {
        // Pick a random candidate
        const wordToReplace = candidateWords[Math.floor(Math.random() * candidateWords.length)];
        
        // Create a safe regex to replace just this instance
        const wordIndex = text.indexOf(wordToReplace);
        if (wordIndex >= 0) {
          const clozedText = 
            text.substring(0, wordIndex) + 
            `[[${wordToReplace}]]` + 
            text.substring(wordIndex + wordToReplace.length);
          
          // Store both truncated and full text
          const truncatedClozedText = clozedText.length > 150 ? 
            clozedText.substring(0, 150) + "..." : clozedText;
          
          cards.push({
            id: `cloze-${Date.now()}-${index}`,
            type: 'cloze',
            text: truncatedClozedText, // Truncated for card display
            fullText: {
              text: clozedText // Full text for modal
            }
          });
        }
      }
    });
    
    // Create multiple choice questions
    const longParagraphs = paragraphs.filter(p => p.textContent.length > 100);
    
    if (longParagraphs.length > 0) {
      // Pick a paragraph for the question
      const paragraph = longParagraphs[Math.floor(Math.random() * longParagraphs.length)];
      const text = paragraph.textContent.trim();
      
      // Find a sentence to use
      const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
      const sentence = sentences[0].trim();
      
      // Create options with the correct one being from the text
      const correctOption = sentence.substring(0, Math.min(60, sentence.length));
      
      // Generate wrong options
      let wrongOptions = [];
      
      // Use sentences from other paragraphs if available
      const otherParagraphs = paragraphs.filter(p => p !== paragraph);
      if (otherParagraphs.length >= 3) {
        wrongOptions = otherParagraphs.slice(0, 3).map(p => {
          const text = p.textContent.trim();
          return text.substring(0, Math.min(60, text.length));
        });
      } else {
        // Generate fake wrong options
        wrongOptions = [
          "This option is not mentioned in the article",
          "This is incorrect information about the topic",
          "This statement is not found in the article"
        ].slice(0, 3);
      }
      
      // Create the full question text for the modal
      const fullQuestionText = "Which of the following is stated in the article?";
      
      cards.push({
        id: `mcq-${Date.now()}-1`,
        type: 'mcq',
        question: fullQuestionText,
        options: [correctOption, ...wrongOptions].sort(() => Math.random() - 0.5),
        answer: correctOption,
        fullText: {
          question: fullQuestionText,
          options: [correctOption, ...wrongOptions].sort(() => Math.random() - 0.5),
          answer: correctOption,
          explanation: `The article states: "${sentence}"`
        }
      });
    }
    
    console.log(`Generated ${cards.length} cards`);
    return cards;
  }

// First, let's add console logging to debug the issue
const handleGenerateFlashcards = async () => {
    console.log("Generate flashcards button clicked");
    console.log("Selected section:", selectedSection);
    
    if (!article) {
      console.error("No article data available");
      return;
    }
    
    setLoading(true);
    
    try {
      // Parse article content
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = article.text;
      
      // Get selected section content or all content
      let sectionContent;
      
      if (selectedSection === 'all') {
        sectionContent = article.text;
        console.log("Using entire article content");
      } else {
        console.log("Looking for section with ID:", selectedSection);
        
        // First, try to find by ID
        let sectionElement = tempDiv.querySelector(`#${selectedSection}`);
        
        // If not found by ID, try to find by heading text content
        if (!sectionElement) {
          const headings = tempDiv.querySelectorAll('h2, h3, h4');
          for (const heading of headings) {
            if (heading.textContent.trim().toLowerCase() === selectedSection.toLowerCase()) {
              sectionElement = heading;
              break;
            }
          }
        }
        
        if (sectionElement) {
          console.log("Section found:", sectionElement.textContent);
          
          // Start with the heading itself
          sectionContent = sectionElement.outerHTML;
          
          // Get all content until the next heading of same or higher level
          let currentLevel = parseInt(sectionElement.tagName.charAt(1));
          let currentElement = sectionElement.nextElementSibling;
          
          while (currentElement) {
            // Stop if we hit another heading of same or higher level
            if (currentElement.tagName && 
                currentElement.tagName.charAt(0) === 'H' && 
                parseInt(currentElement.tagName.charAt(1)) <= currentLevel) {
              break;
            }
            
            sectionContent += currentElement.outerHTML;
            currentElement = currentElement.nextElementSibling;
          }
          
          console.log("Section content length:", sectionContent.length);
        } else {
          console.warn("Section not found, using full article content");
          sectionContent = article.text;
        }
      }
      
      // Generate cards using the built-in generator function
      const cards = generateBasicFlashcards(sectionContent, reviewSettings.difficulty);
      console.log("Generated cards:", cards);
      setAutoGeneratedCards(cards);
      
    } catch (error) {
      console.error('Error generating flashcards:', error);
      // Add a fallback card
      setAutoGeneratedCards([
        {
          id: `qa-${Date.now()}-error`,
          type: 'qa',
          front: `What is ${article.title}?`,
          back: `${article.title} is a topic covered in this Wikipedia article.`
        }
      ]);
    } finally {
      setLoading(false);
    }
  };

  // Start a review session
  const startReview = () => {
    // Combine auto-generated and user cards
    const allCards = [...autoGeneratedCards, ...userCards];
    
    // Filter cards by type if needed
    const filteredCards = allCards.filter(card => 
      reviewSettings.cardTypes.includes(card.type)
    );
    
    // Limit deck size
    const deckSize = Math.min(reviewSettings.deckSize, filteredCards.length);
    const selectedCards = filteredCards
      .sort(() => 0.5 - Math.random()) // Shuffle
      .slice(0, deckSize);
    
    // Set up review deck
    setReviewDeck(
      selectedCards.map(card => ({
        ...card,
        reviewed: false,
        correct: null,
        nextReviewDate: new Date()
      }))
    );
    
    setReviewInProgress(true);
    setActiveTab('review');
  };

  // End a review session
  const endReview = () => {
    setReviewInProgress(false);
    
    // Update cards with new review information
    const updatedUserCards = [...userCards];
    
    reviewDeck.forEach(reviewedCard => {
      // Find if it's a user card
      const cardIndex = updatedUserCards.findIndex(c => c.id === reviewedCard.id);
      
      if (cardIndex >= 0) {
        // Update existing user card
        updatedUserCards[cardIndex] = {
          ...updatedUserCards[cardIndex],
          lastReviewed: new Date(),
          nextReviewDate: reviewedCard.nextReviewDate,
          reviewCount: (updatedUserCards[cardIndex].reviewCount || 0) + 1,
          correctCount: (updatedUserCards[cardIndex].correctCount || 0) + (reviewedCard.correct ? 1 : 0)
        };
      } else if (reviewedCard.correct) {
        // If it was an auto-generated card and was answered correctly, add to user cards
        updatedUserCards.push({
          ...reviewedCard,
          lastReviewed: new Date(),
          nextReviewDate: reviewedCard.nextReviewDate,
          reviewCount: 1,
          correctCount: reviewedCard.correct ? 1 : 0
        });
      }
    });
    
    // Save updated user cards
    setUserCards(updatedUserCards);
    saveUserCards(updatedUserCards);
  };


  const showFullCardContent = (card) => {
    let title = '';
    let content = '';
    
    if (card.type === 'qa') {
      // Use fullText if available, otherwise fallback to the regular front/back
      const frontText = card.fullText?.front || card.front;
      const backText = card.fullText?.back || card.back;
      
      title = frontText;
      content = backText;
    } 
    // For cloze cards
    else if (card.type === 'cloze') {
      title = 'Fill in the Blank';
      // Use fullText if available, otherwise fallback to the regular text
      const fullClozedText = card.fullText?.text || card.text;
      
      const htmlContent = fullClozedText.replace(/\[\[([^\]]+)\]\]/g, '<mark class="bg-yellow-200 px-1">$1</mark>');
      setModalContent({ 
        title, 
        content: <div dangerouslySetInnerHTML={{ __html: htmlContent }} />
      });
      return; // Return early since we've already set modalContent
    } 
    // For MCQ cards
    else if (card.type === 'mcq') {
      // Use fullText if available, otherwise fallback to the regular question/options
      const question = card.fullText?.question || card.question;
      const options = card.fullText?.options || card.options;
      const answer = card.fullText?.answer || card.answer;
      const explanation = card.fullText?.explanation || '';
      
      title = question;
      setModalContent({
        title,
        content: (
          <>
            <div className="mb-4">{question}</div>
            <div className="font-semibold mb-2">Options:</div>
            <ul className="list-disc pl-5 mb-4">
              {options.map((option, i) => (
                <li key={i} className={option === answer ? 'font-bold text-green-600' : ''}>
                  {option} {option === answer && '✓'}
                </li>
              ))}
            </ul>
            <div className="font-semibold mb-2">Correct answer: <span className="text-green-600">{answer}</span></div>
            {explanation && (
              <div className="mt-4 p-3 bg-blue-50 border border-blue-100 rounded">
                <div className="font-semibold mb-1">Explanation:</div>
                <div>{explanation}</div>
              </div>
            )}
          </>
        )
      });
      return; // Return early since we've already set modalContent
    }
    
    // This will only run for 'qa' type cards
    setModalContent({ title, content });
    setModalOpen(true);
  };  
  // Add a custom card
  const addCustomCard = (newCard) => {
    const updatedCards = [
      ...userCards, 
      {
        ...newCard,
        id: `custom-${Date.now()}`,
        createdAt: new Date(),
        reviewCount: 0,
        correctCount: 0
      }
    ];
    
    setUserCards(updatedCards);
    saveUserCards(updatedCards);
  };

  // Delete a card
  const deleteCard = (cardId) => {
    const updatedCards = userCards.filter(card => card.id !== cardId);
    setUserCards(updatedCards);
    saveUserCards(updatedCards);
  };

  // Export cards to Anki
  const exportToAnki = () => {
    // Create a CSV or Anki-compatible export file
    const cardsToExport = [...userCards];
    
    // Format for Anki: front,back,tags
    const csvContent = cardsToExport.map(card => {
      if (card.type === 'qa') {
        return `"${card.front}","${card.back}","${title}"`;
      } else if (card.type === 'cloze') {
        // Format cloze deletions for Anki
        return `"${card.text.replace(/\[\[([^\]]+)\]\]/g, '{{c1::$1}}')}"," ","${title}"`;
      } else {
        return `"${card.question}","${card.answer}","${title}"`;
      }
    }).join('\n');
    
    // Create and download the file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `flashcards-${title.replace(/\s+/g, '-')}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Update review settings
  const updateReviewSettings = (settings) => {
    setReviewSettings({
      ...reviewSettings,
      ...settings
    });
  };

  return (
    <div className="container mx-auto px-4 py-6">
      <div className="bg-white border border-gray-200 rounded p-6">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-2xl font-bold">Flashcards: {title}</h1>
            <Link to={`/article/${encodeURIComponent(title)}`} className="text-[#36c] hover:underline">
              ← Back to article
            </Link>
          </div>
          
          {/* Tab navigation */}
          <div className="flex border border-gray-200 rounded overflow-hidden">
            <button 
              onClick={() => setActiveTab('generate')}
              className={`px-4 py-2 ${activeTab === 'generate' ? 'bg-[#36c] text-white' : 'bg-gray-100'}`}
              disabled={reviewInProgress}
            >
              Generate Cards
            </button>
            <button 
              onClick={() => setActiveTab('custom')}
              className={`px-4 py-2 ${activeTab === 'custom' ? 'bg-[#36c] text-white' : 'bg-gray-100'}`}
              disabled={reviewInProgress}
            >
              Custom Cards
            </button>
            <button 
              onClick={() => setActiveTab('review')}
              className={`px-4 py-2 ${activeTab === 'review' ? 'bg-[#36c] text-white' : 'bg-gray-100'}`}
              disabled={reviewInProgress}
            >
              Review Cards
            </button>
          </div>
        </div>
        
        {loading ? (
          <div className="flex justify-center items-center h-64">
            <div className="loader">Loading...</div>
          </div>
        ) : error ? (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
            <p>{error}</p>
          </div>
        ) : (
          <div>
            {/* Generate cards tab */}
            {activeTab === 'generate' && !reviewInProgress && (
              <div>
                <div className="mb-6 bg-[#f8f9fa] p-4 rounded border border-gray-200">
                  <h2 className="text-xl font-bold mb-4">Generate Flashcards</h2>
                  
                  <div className="flex flex-wrap gap-4 mb-4">
                    {/* <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Section</label>
                      <select 
                        value={selectedSection}
                        onChange={(e) => setSelectedSection(e.target.value)}
                        className="border border-gray-300 rounded px-3 py-2"
                      >
                        {sections.map(section => (
                          <option key={section.id} value={section.id}>
                            {section.level > 1 ? '  '.repeat(section.level - 1) + section.title : section.title}
                          </option>
                        ))}
                      </select>
                    </div> */}
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Difficulty</label>
                      <select 
                        value={reviewSettings.difficulty}
                        onChange={(e) => updateReviewSettings({ difficulty: e.target.value })}
                        className="border border-gray-300 rounded px-3 py-2"
                      >
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard">Hard</option>
                      </select>
                    </div>
                    
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Card Types</label>
                      <div className="flex gap-2">
                        {[
                          { value: 'qa', label: 'Q&A' },
                          { value: 'cloze', label: 'Cloze' },
                          { value: 'mcq', label: 'Multiple Choice' }
                        ].map(type => (
                          <label key={type.value} className="inline-flex items-center">
                            <input 
                              type="checkbox"
                              checked={reviewSettings.cardTypes.includes(type.value)}
                              onChange={(e) => {
                                if (e.target.checked) {
                                  updateReviewSettings({ 
                                    cardTypes: [...reviewSettings.cardTypes, type.value] 
                                  });
                                } else {
                                  updateReviewSettings({ 
                                    cardTypes: reviewSettings.cardTypes.filter(t => t !== type.value) 
                                  });
                                }
                              }}
                              className="form-checkbox h-4 w-4 text-blue-500"
                            />
                            <span className="ml-2 text-sm">{type.label}</span>
                          </label>
                        ))}
                      </div>
                    </div>
                  </div>
                  
                  <button 
                    onClick={handleGenerateFlashcards}
                    className="bg-[#36c] hover:[#36f] text-white px-4 py-2 rounded"
                    disabled={loading}
                    >
                    {loading ? 'Generating...' : 'Generate Flashcards'}
                  </button>
                </div>
                
                {/* Generated cards */}
                {autoGeneratedCards.length > 0 && (
                  <div>
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="text-lg font-bold">Generated Cards ({autoGeneratedCards.length})</h3>
                      <div className="flex gap-2">
                        <button 
                          onClick={() => startReview()}
                          className="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm"
                        >
                          Start Review
                        </button>
                        <button 
                          onClick={exportToAnki}
                          className="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded text-sm"
                        >
                          Export to Anki
                        </button>
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                      {autoGeneratedCards.map(card => (
                        <div 
                          key={card.id} 
                          className="border border-gray-200 rounded p-4 hover:shadow-md transition-shadow"
                          onClick={() => showFullCardContent(card)}

                        >
                          {card.type === 'qa' && (
                            <>
                              <div className="font-bold mb-2">{card.front}</div>
                              <div className="text-gray-600">{card.back}</div>
                            </>
                          )}
                          
                          {card.type === 'cloze' && (
                            <div>
                              {card.text.split(/\[\[([^\]]+)\]\]/).map((part, i) => 
                                i % 2 === 0 ? 
                                  part : 
                                  <span key={i} className="bg-yellow-200 px-1 rounded">
                                    {part}
                                  </span>
                              )}
                            </div>
                          )}
                          
                          {card.type === 'mcq' && (
                            <>
                              <div className="font-bold mb-2">{card.question}</div>
                              <div className="space-y-1">
                                {card.options.map((option, i) => (
                                  <div key={i} className={`
                                    px-2 py-1 rounded 
                                    ${option === card.answer ? 'bg-green-100 border border-green-300' : 'bg-gray-50'}
                                  `}>
                                    {option}
                                  </div>
                                ))}
                              </div>
                            </>
                          )}
                          <div className="mt-2 text-xs text-blue-500 text-right">
                            Click to view full content
                            </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
            
            {/* Custom cards tab */}
            {activeTab === 'custom' && !reviewInProgress && (
              <div>
                <FlashcardCreator 
                  onAddCard={addCustomCard} 
                  articleTitle={title}
                />
                
                {userCards.length > 0 && (
                  <div className="mt-8">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="text-lg font-bold">Your Custom Cards ({userCards.length})</h3>
                      <div className="flex gap-2">
                        <button 
                          onClick={() => startReview()}
                          className="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm"
                        >
                          Review Cards
                        </button>
                        <button 
                          onClick={exportToAnki}
                          className="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded text-sm"
                        >
                          Export to Anki
                        </button>
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                      {userCards.map(card => (
                        <div 
                          key={card.id} 
                          className="border border-gray-200 rounded p-4 hover:shadow-md transition-shadow relative"
                          onClick={(e) => {
                            // Don't open modal if clicking the delete button
                            if (e.target.closest('button') && e.target.closest('button').title === 'Delete card') {
                              e.stopPropagation();
                              return;
                            }
                            showFullCardContent(card);
                          }}
                        >
                          <button 
                            onClick={() => deleteCard(card.id)}
                            className="absolute top-2 right-2 text-red-500 hover:text-red-700"
                            title="Delete card"
                          >
                            ×
                          </button>
                          
                          {card.type === 'qa' && (
                            <>
                              <div className="font-bold mb-2">{card.front}</div>
                              <div className="text-gray-600">{card.back}</div>
                            </>
                          )}
                          
                          {card.type === 'cloze' && (
                            <div>
                              {card.text.split(/\[\[([^\]]+)\]\]/).map((part, i) => 
                                i % 2 === 0 ? 
                                  part : 
                                  <span key={i} className="bg-yellow-200 px-1 rounded">
                                    {part}
                                  </span>
                              )}
                            </div>
                          )}
                          
                          {card.type === 'mcq' && (
                            <>
                              <div className="font-bold mb-2">{card.question}</div>
                              <div className="space-y-1">
                                {card.options.map((option, i) => (
                                  <div key={i} className={`
                                    px-2 py-1 rounded 
                                    ${option === card.answer ? 'bg-green-100 border border-green-300' : 'bg-gray-50'}
                                  `}>
                                    {option}
                                  </div>
                                ))}
                              </div>
                            </>
                          )}
                          
                          {card.reviewCount > 0 && (
                            <div className="mt-2 text-xs text-gray-500">
                              Reviewed: {card.reviewCount} times | 
                              Accuracy: {Math.round((card.correctCount / card.reviewCount) * 100)}%
                            </div>
                          )}
                          <div className="mt-2 text-xs text-blue-500 text-right">
                            Click to view full content
                           </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
            
            {/* Review tab or review in progress */}
            {(activeTab === 'review' || reviewInProgress) && (
              <div>
                {reviewInProgress ? (
                  <FlashcardReview 
                    deck={reviewDeck}
                    setDeck={setReviewDeck}
                    onCompleteReview={endReview}
                  />
                ) : (
                  <div className="bg-gray-50 p-6 rounded border border-gray-200">
                    <h2 className="text-xl font-bold mb-4">Review Setup</h2>
                    
                    <div className="mb-4">
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Card Types to Include
                      </label>
                      <div className="flex gap-3">
                        {[
                          { value: 'qa', label: 'Question & Answer' },
                          { value: 'cloze', label: 'Fill in the Blank' },
                          { value: 'mcq', label: 'Multiple Choice' }
                        ].map(type => (
                          <label key={type.value} className="inline-flex items-center">
                            <input 
                              type="checkbox"
                              checked={reviewSettings.cardTypes.includes(type.value)}
                              onChange={(e) => {
                                if (e.target.checked) {
                                  updateReviewSettings({ 
                                    cardTypes: [...reviewSettings.cardTypes, type.value] 
                                  });
                                } else {
                                  updateReviewSettings({ 
                                    cardTypes: reviewSettings.cardTypes.filter(t => t !== type.value) 
                                  });
                                }
                              }}
                              className="form-checkbox h-4 w-4 text-blue-500"
                            />
                            <span className="ml-2">{type.label}</span>
                          </label>
                        ))}
                      </div>
                    </div>
                    
                    <div className="mb-4">
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Number of Cards
                      </label>
                      <input 
                        type="number"
                        min="1"
                        max="50"
                        value={reviewSettings.deckSize}
                        onChange={(e) => updateReviewSettings({ 
                          deckSize: parseInt(e.target.value) || 10 
                        })}
                        className="border border-gray-300 rounded px-3 py-2 w-24"
                      />
                    </div>
                    
                    <div className="mb-6">
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Difficulty
                      </label>
                      <select 
                        value={reviewSettings.difficulty}
                        onChange={(e) => updateReviewSettings({ difficulty: e.target.value })}
                        className="border border-gray-300 rounded px-3 py-2"
                      >
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard">Hard</option>
                      </select>
                    </div>
                    
                    <div className="flex space-x-4">
                      <button
                        onClick={() => startReview()}
                        className="bg-[#36c] hover:bg-blue-600 text-white px-4 py-2 rounded"
                        disabled={autoGeneratedCards.length === 0 && userCards.length === 0}
                      >
                        Start Review Session
                      </button>
                      
                      <button
                        onClick={handleGenerateFlashcards}
                        className="bg-[#EBEBD2] hover:bg-[#EBEBD7] text-black px-4 py-2 rounded"
                      >
                        Generate New Cards
                      </button>
                    </div>
                    
                    <div className="mt-6 text-gray-700">
                      <p className="text-sm">
                        {autoGeneratedCards.length + userCards.length} cards available for review.
                        {autoGeneratedCards.length === 0 && userCards.length === 0 && (
                          <span className="text-orange-600 ml-2">
                            Generate or create cards first to start a review.
                          </span>
                        )}
                      </p>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        )}
      </div>
      <FullTextModal 
        isOpen={modalOpen}
        onClose={() => setModalOpen(false)}
        title={modalContent.title}
        content={modalContent.content}
        />
    </div>
  );
};

export default FlashcardsPage;